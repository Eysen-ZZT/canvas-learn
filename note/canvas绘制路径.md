## Canvas 中的连点成线

Canvas 中的渲染上下文也提供了类似上面这种机制用于画线(图形)

| 方法            | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| ctx.beginPath() | 开启一个新路径                                               |
| ctx.move(x,y)   | 确定起点坐标，也就是先把画笔移动到某个位置                   |
| ctx.lineTo(x,y) | 然后确定好下一个位置 (x1,y1)，可以使用多次确定多个点位       |
| ctx.closePath() | 如果我们要将图形闭合，则还要绘制到起始点，这个操作是可选的，如果不选择就不会闭合 |
| ctx.stroke()    | 根据当前的画线样式，绘制当前或已经存在的路径                 |

## arcTo() 方法

`arcTo()` 根据控制点和半径绘制圆弧路径，使用当前的描点(前一个 `moveTo()` 或 `lineTo()` 等函数的止点)，根据当前描点与给定的控制点1连接的直线，和控制点1与控制点2连接的直线，作为使用指定半径的圆的切线，画出两条切线之间的弧线路径

```
void ctx.arcTo(x1, y1, x2, y2, radius);
```

| 参数   | 说明                    |
| ------ | ----------------------- |
| x1     | 第一个控制点的 x 轴坐标 |
| y1     | 第一个控制点的 y 轴坐标 |
| x2     | 第二个控制点的 x 轴坐标 |
| y2     | 第二个控制点的 y 轴坐标 |
| radius | 圆弧的半径              |

> 注意： `arcTo()` 方法绘制出来的也是虚拟路径，需要使用 `stroke()` 实体化

## arc() 方法

`arc()` 用于绘制圆弧，圆弧路径的圆心在 (x, y) 位置，半径为 r ，根据anticlockwise （默认为顺时针）指定的方向从 startAngle 开始绘制，到 endAngle 结束

```
void ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);
```

| 参数          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| x             | 圆弧中心（圆心）的 x 轴坐标                                  |
| y             | 圆弧中心（圆心）的 y 轴坐标                                  |
| radius        | 圆弧的半径                                                   |
| startAngle    | 圆弧的起始点， x轴方向开始计算，单位以弧度表示               |
| endAngle      | 圆弧的终点， 单位以弧度表示                                  |
| anticlockwise | 可选， bool 类型 ，如果为 true，逆时针绘制圆弧，反之，顺时针绘制，默认为 false |

> 注意： `arc()` 方法绘制出来的是虚拟路径，需要使用 `stroke()` 实体化

## Canvas bezierCurveTo() 方法

Canvas 提供了方法 `bezierCurveTo()` 用来绘制三次贝塞尔曲线

```
void ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
```

方法需要三个点。 第一、第二个点是控制点，第三个点是结束点

起始点是当前路径的最后一个点，绘制贝赛尔曲线前，可以通过调用 `moveTo()` 进行修改

| 参数 | 说明                    |
| ---- | ----------------------- |
| cp1x | 第一个控制点的 x 轴坐标 |
| cp1y | 第一个控制点的 y 轴坐标 |
| cp2x | 第二个控制点的 x 轴坐标 |
| cp2y | 第二个控制点的 y 轴坐标 |
| x    | 结束点的 x 轴坐标       |
| y    | 结束点的 y 轴坐标       |

> **注意**：`bezierCurveTo()` 方法绘制出来的是虚拟路径，需要使用 `stroke()` 实体化

## fill() 方法

`fill()` 方法根据当前的填充样式，填充当前或已存在的路径，可选的填充方法有非零环绕或者奇偶环绕

```
void ctx.fill();
void ctx.fill(fillRule);
void ctx.fill(path, fillRule);
```

| 参数     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| fillRule | 一种算法，决定点是在路径内还是在路径外，允许的值： "nonzero": 非零环绕规则， 默认的规则 "evenodd": 奇偶环绕规则 |
| path     | 可选，需要填充的 `Path2D` 路径                               |
